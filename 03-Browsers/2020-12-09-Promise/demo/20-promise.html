<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Promise</title>
</head>
<body>

    <h1>Promise</h1>

    MDN:
    <cite>
        "The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value."
    </cite>

    <h2>Links</h2>
    MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">Using Promises</a>
    <br>
    MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>

    <h2>Promise.resolve()</h2>

    MDN - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve">Promise.resolve()</a>:
    <blockquote>
        The Promise.resolve() method returns a Promise object that is resolved with a given value. If the value is a promise, that promise is returned; if the value is a thenable (i.e. has a "then" method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.
    </blockquote>
    <h2>Promise.prototype.then()</h2>


    <hr>

    <h2>Demonstration</h2>

    <div id="target"></div>

</body>
<script>

    function wait(milliseconds) {
                                            // after the time out the callback "resolve" will be called, - that callback yields a fullfilled promise.
        return new Promise( resolve => window.setTimeout(resolve, milliseconds));
    }

    function errorHandler(value) {
        console.error("Promise failed with value " + value);
    }

    let element = document.getElementById("target");

    /*
    wait(1000)
    .then( () => element.append(" 1 "), errorHandler) // the errorHandler-callback is optional
    /**/

    /*
    wait(2000)
    .then( () => element.append(" 2 "));
    /**/

    /*
    wait(3000)
    .then( () => element.append(" 3 "))
    .then( () => element.append(" 4 "));
    /**/

    element.append(" 0 ");

</script>
</html>
