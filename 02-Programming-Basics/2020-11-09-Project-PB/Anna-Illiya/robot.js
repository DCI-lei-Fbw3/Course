const { run } = require("jest");
const { start } = require("repl");

var roads = [
  "Alice's House-Bob's House",
  "Alice's House-Cabin",
  "Alice's House-Post Office",
  "Bob's House-Town Hall",
  "Daria's House-Ernie's House",
  "Daria's House-Town Hall",
  "Ernie's House-Grete's House",
  "Grete's House-Farm",
  "Grete's House-Shop",
  "Marketplace-Farm",
  "Marketplace-Post Office",
  "Marketplace-Shop",
  "Marketplace-Town Hall",
  "Shop-Town Hall",
];

function buildGraph(edges) {
  let graph = Object.create(null); //Could also be "let graph = {}" but then has all object prototypes
  function addEdge(from, to) {
    if (graph[from] === undefined) {
      //Changed "== null" to "=== undefined" to be more precise
      graph[from] = [to];
    } else {
      if (!graph[from].includes(to)) {
        //Added an if statement to avoid doubling of placenames in the arrays if the data is corrupted
        graph[from].push(to); //Pushes new destination to existing object property array
      }
    }
  }
  for (let [from, to] of edges.map((r) => r.split("-"))) {
    //Splits each string then uses each location as a property
    addEdge(from, to);
    addEdge(to, from); //Ensures the roads are represented in both directions
  }
  return graph;
}

// graph = {  //example of first few entries after running buildGraph
//   "Alice's House": ["Bob's House", "Cabin", "Post Office"],
//   "Bob's House": ["Alice's House, "],
//   "Cabin" : ["Alice's House"],
//   "Post Office" : ["Alice's House"]
// }

var roadGraph = buildGraph(roads);

class VillageState {
  //Removed var VillageState =
  //Change name later!!! ROBOTSTATE BISH
  constructor(place, parcels) {
    this.place = place; //place = where the robot is now
    this.parcels = parcels; //parcels = an array of parcels with (at least) two properties "Place" = current location; "address" = to.
  }

  move(destination) {
    //destination = where the robot moves to next
    if (!roadGraph[this.place].includes(destination)) {
      return this; // If no road exists from the current location to destination, returns current state since it's not a valid move.
    } else {
      let parcels = this.parcels //[{place: "Alice's House", address: "Town Hall"}, {place: "Cabin", address: "Post Office"}]  //"Place" = current location; "address" = to.
        .map((p) => {
          if (p.place != this.place) return p; //Don't update parcel if the places don't match (no package to pick up)
          return { place: destination, address: p.address }; //If there is a package to pick up in original location, update the location of that package to the destination where the robot is moving, but keep the address the same
        })
        .filter((p) => p.place != p.address); //Only return packages which have not reached their destination (i.e. still have to be delivered)
      return new VillageState(destination, parcels); //ensures the state is updated so that robot's new place is the move's destination
    }
  }
}

function runRobot(state, robot, memory) {
  //Higher-order function (robot is a function returning an object with a direction property)
  for (let turn = 0; ; turn++) {
    if (state.parcels.length == 0) {
      //Terminates loop when all parcels are delivered
      return turn; //Changed the log to a return statement for using the compareRobot function
    }
    let action = robot(state, memory); // let action = randomRobot(state,memory) = {direction: "Cabin"}
    // {direction: "Alice's House"}// Takes in the robot function parameter and feeds it the other two parameters (state, memory)
    state = state.move(action.direction); //Generates a new state object (e.g.taking the random direction generated by randomRobot() function)
    memory = action.memory; //No memory parameter passed in random example // memory minus first route location in mailRoute example
  }
}

function randomPick(array) {
  let choice = Math.floor(Math.random() * array.length);
  return array[choice];
}

function randomRobot(state) {
  return { direction: randomPick(roadGraph[state.place]) };
}

runRobot(VillageState.random(), randomRobot); //robot === randomRobot

VillageState.random = function (parcelCount = 5) {
  let parcels = [];
  for (let i = 0; i < parcelCount; i++) {
    let address = randomPick(Object.keys(roadGraph)); //picks a random destination address from the keys of the roadGraph
    let place;
    do {
      //Loop which generates a random starting location from the keys of roadGraph, but repeats if it is the same as the address
      place = randomPick(Object.keys(roadGraph));
    } while (place == address);
    parcels.push({ place, address }); //Push the new, random parcel information to the parcel list
  }
  return new VillageState("Post Office", parcels); //Return the start location as 'Post Office' and add the parcel list to the state
};

//Example code from the book:
runRobot(VillageState.random(), randomRobot); //randomRobot returns an object with a random 'direction' property

var mailRoute = [
  "Alice's House",
  "Cabin",
  "Alice's House",
  "Bob's House",
  "Town Hall",
  "Daria's House",
  "Ernie's House",
  "Grete's House",
  "Shop",
  "Grete's House",
  "Farm",
  "Marketplace",
  "Post Office",
];

function routeRobot(state, memory) {
  if (memory.length == 0) {
    memory = mailRoute;
  }
  return { direction: memory[0], memory: memory.slice(1) };
}

runRobot(VillageState.random(), routeRobot, []);

function findRoute(graph, from, to) {
  let work = [{ at: from, route: [] }]; //set first property in work arr to start location
  for (let i = 0; i < work.length; i++) {
    //runs once to begin with
    let { at, route } = work[i]; //destructure current index of work object and assign to variables, at = from(start location), route = []
    for (let place of graph[at]) {
      //iterates through the values of VillageState[location] and calls it 'place' during loop, e.g. ["Alice's House", "Post Office", "Cabin"]
      if (place == to) return route.concat(place); //Add that place to the route array if it is the target location and return that. This will be the first route found.
      if (!work.some((w) => w.at == place)) {
        //Does the work array already contain any object leaving from this 'place'? If so, continue. If not...
        work.push({ at: place, route: route.concat(place) }); //Push this place and the extended route to the work array
      }
    }
  }
}
// console.log(findRoute(roadGraph, "Alice's House", "Marketplace"));

// Explanation of above:
// - work[0].at = "Alice's House"
// - runs through each of the three locations connected to Alice's house: none are the target location (to) and none are already in the work array, so all are pushed to it
// - "Bob's House" and "Cabin" both are only connected to Alice's House and are not the target location, so neither is pushed to the work array
// - "Post Office" is the last to be iterated through, and in it we find "Grete's House" (or something) which is added to the work array, before "Marketplace" is found: it's
//    the target location so we return the route from Post Office + Marketplace, which is "Post Office", "Marketplace"

function goalOrientedRobot({ place, parcels }, route) {
  //takes in the destructured state and an empty memory property. Why not use the same term?
  if (route.length == 0) {
    let parcel = parcels[0]; //Takes the parcel list from state

    if (parcel.place != place) {
      //If we're not in the starting location, move there
      route = findRoute(roadGraph, place, parcel.place);
    } else {
      //If we are in the starting location, find a way to the address
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  return { direction: route[0], memory: route.slice(1) };
}

function annaRobot({ place, parcels }, route) {
  function findNearestParcel() {
    let nearestParcel = parcels[0]; //default parcel
    let shortestDistance = findRoute(roadGraph, place, parcels[0].place).length; //default/base route length
    for (parcel of parcels) {
      let parcelDistance = findRoute(roadGraph, place, parcel.place).length;
      if (parcelDistance < shortestDistance) {
        //sets the current parcel if it is closer than all previous
        nearestParcel = parcel;
        shortestDistance = parcelDistance;
      } else if (parcelDistance === shortestDistance) {
        for (parcel2 of parcels) {
          if (parcel.address === parcel2.place) {
            //If distance is the same, check if it will be delivered somewhere another package is waiting
            nearestParcel = parcel;
            break;
          }
        }
      }
    }
    return nearestParcel;
  }
  if (route.length == 0) {
    let currentParcel = findNearestParcel();
    if (currentParcel.place === place) {
      route = findRoute(roadGraph, place, currentParcel.address);
    } else {
      route = findRoute(roadGraph, place, currentParcel.place);
    }
  }
  return { direction: route[0], memory: route.slice(1) };
}

function annaRobot2({ place, parcels }, route) {
  //without the 'package waiting' check
  function findNearestParcel() {
    let nearestParcel = parcels[0]; //default parcel
    let shortestDistance = findRoute(roadGraph, place, parcels[0].place).length; //default/base route length
    for (parcel of parcels) {
      let parcelDistance = findRoute(roadGraph, place, parcel.place).length;
      if (parcelDistance < shortestDistance) {
        //sets the current parcel if it is closer than all previous
        nearestParcel = parcel;
        shortestDistance = parcelDistance;
      }
    }
    return nearestParcel;
  }
  if (route.length == 0) {
    let currentParcel = findNearestParcel();
    if (currentParcel.place === place) {
      route = findRoute(roadGraph, place, currentParcel.address);
    } else {
      route = findRoute(roadGraph, place, currentParcel.place);
    }
  }
  return { direction: route[0], memory: route.slice(1) };
}

// annaRobot(VillageState.random(), []);

console.log(runRobot(VillageState.random(), annaRobot, []));

//Version without destructuring of state
// function goalOrientedRobot(state, route) {
//   if (route.length == 0) {
//     let parcel = state.parcels[0];
//     if (parcel.place != state.place) {
//       route = findRoute(roadGraph, state.place, parcel.place);
//     } else {
//       route = findRoute(roadGraph, state.place, parcel.address);
//     }
//   }
//   return { direction: route[0], memory: route.slice(1) };
// }

// runRobot(VillageState.random(), goalOrientedRobot, []);

//This code currently works by evaluating all parcels separately. The goal with an updated Robot would be to ensure that multiple packages can be delivered together, perhaps by checking all other parcel pickup and goal locations whenever a new location is reached?

//Attempt to abstract the VillageState class a bit more
// class RobotState {
//   constructor(place, parcels) {
//     this.place = place; //place = where the robot is now
//     this.parcels = parcels; //parcels = an array of parcels with (at least) two properties "Place" = current location; "address" = to.
//   }
//   move(destination) {
//     //destination = where the robot moves to next
//     if (!roadGraph[this.place].includes(destination)) {
//       return this; // If no road exists from the current location to destination, returns current state since it's not a valid move.
//     } else {
//       let uncollectedParcels = this.parcels.map((p) => {
//         if (p.place != this.place) return p; //Don't update parcel if the places don't match (no package to pick up)
//         return { place: destination, address: p.address }; //If there is a package to pick up in original location, update the location of that package to the destination where the robot is moving, but keep the address the same
//       })
//       let undeliveredParcels = uncollectedParcels.filter((p) => p.place != p.address)
//       return new RobotState(destination, undeliveredParcels); //ensures the state is updated so that robot's new place is the move's destination
//     }
//   }
// }

// console.log(runRobot(VillageState.random(), randomRobot));
// function compareRobots(robot1, route1, robot2, route2) {
//   //Version with 100 packages
//   let startState = VillageState.random(100);
//   let turnCount1 = runRobot(startState, robot1, route1);
//   let turnCount2 = runRobot(startState, robot2, route2);
//   return `Results: 100 packages delivered by: \n Robot1 in ${turnCount1} turns \n Robot2 in ${turnCount2} turns`;
// }

function compareRobots(robot1, route1, robot2, route2) {
  //Version with 100 tasks of 5 packages each
  let robot1TotalTurns = 0;
  let robot2TotalTurns = 0;
  for (let i = 0; i < 100; i++) {
    let startState = VillageState.random();
    robot1TotalTurns += runRobot(startState, robot1, route1);
    robot2TotalTurns += runRobot(startState, robot2, route2);
  }
  let robot1AverageTurns = Math.round(robot1TotalTurns / 100);
  let robot2AverageTurns = Math.round(robot2TotalTurns / 100);
  return `Results: 100 tasks found average moves for 5 packages as...
  \n Robot1 in ${robot1AverageTurns} turns \n Robot2 in ${robot2AverageTurns} turns`;
}

console.log(compareRobots(annaRobot, [], goalOrientedRobot, []));

// //Exercise 3: Persistent Group

class PGroup {
  constructor(arr) {
    this.state = arr ? arr : [];
    //this.empty = new PGroup([]);
  }
  add(value) {
    if (this.state.includes(value)) {
      console.log("Invalid: entry already exists");
      return this;
    } else {
      console.log(`${value} has been added`);
      return new PGroup(this.state.concat(value));
    }
  }
  delete(value) {
    if (this.state.includes(value)) {
      console.log(`${value} has been removed`);
      return new PGroup(this.state.filter((a) => a != value));
    } else {
      console.log("Invalid: no such entry exists");
      return this;
    }
  }
  has(value) {
    return this.state.includes(value) ? true : false;
  }
}

PGroup.empty = new PGroup([]);

let a = PGroup.empty.add("a");
console.log(a);
let ab = a.add("b");
console.log(a);
let b = ab.delete("a");
console.log(ab);

console.log(b.has("b"));
// → true
console.log(a.has("b"));
// → false
console.log(b.has("a"));
// → false
